module AATree
exports all
definitions
types 
    AATreeType = ?;

    AATreeLevel = nat1; 

    AATreeNode :: 
        element: AATreeType 
        level  : AATreeLevel
        left   : [AATreeNode] 
        right  : [AATreeNode]
    inv mk_AATreeNode(x, -, -, -) == x <> nil;

    --@doc total (<) order between set values. 
    --     bool result will ignore repeated insertions.
    --     int result could be used to error on repeated insertions. 
    AATreeOrder = (AATreeType * AATreeType -> bool);

    AATreeSet :: 
        root : [AATreeNode]
        order: AATreeOrder;
    
functions 

    data[@T]: [AATreeNode] -> [@T]
    data(n) == if n = nil then nil else n.element
    --pre  (n <> nil => n.element <> nil)
    post (n = nil 
          <=> 
          --Warning(5037) element should not be lambda typed; adding @T prevents this
          (RESULT = nil));

    dataset: [AATreeNode] -> set of AATreeType 
    dataset(n) == 
        if n = nil then {} else {n.element} union dataset(n.left) union dataset(n.right)
    post 
        (n = nil <=> RESULT = {})
    measure 
        is not yet specified;

    level: [AATreeNode] -> nat
    level(n) == if (n = nil) then 0 else n.level
    post (n <> nil <=> is_AATreeLevel(RESULT));

    left: [AATreeNode] -> [AATreeNode]
    left(n) == if n = nil then nil else n.left
    post (n = nil => RESULT = nil); 

    right: [AATreeNode] -> [AATreeNode]
    right(n) == if n = nil then nil else n.right
    post (n = nil => RESULT = nil); 

    skew: [AATreeNode] -> [AATreeNode]
    skew(n) ==  
        if n = nil then nil 
        else 
            let mk_AATreeNode(x, k, t, u) = n in       
                --@doc level(nil)=0, which k can never be given AATreeLevel
                if /*t <> nil and*/ k = level(t) then 
                    mk_AATreeNode(data(t), k, left(t), mk_AATreeNode(x, k, right(t), u))
                else -- n <> nil of course. 
                    n
    post (n = nil <=> RESULT = nil);

    split: [AATreeNode] -> [AATreeNode]
    split(n) == 
        if n = nil then nil 
        else 
            let mk_AATreeNode(x, k, t, u) = n in 
                --@doc level(nil)=0, which k can never be given AATreeLevel
                if /*u <> nil and*/ k = level(right(u)) then 
                    mk_AATreeNode(data(u), k+1, mk_AATreeNode(x, k, t, left(u)), right(u))
                else 
                    n
    post (n = nil <=> RESULT = nil);

    wf: [AATreeNode] -> bool 
    wf(n) == 
        (n = nil)
        or 
        (let mk_AATreeNode(-, k, t, u) = n in 
            if t = nil then 
                k = 1 and (u = nil or (level(u) = 1 and left(u) = nil and right(u) = nil))
            else 
                wf(t) and wf(u) and u <> nil and 
                level(t) < k and level(u) <= k and level(right(u)) < k 
        )
    measure 
        is not yet specified;
    
    insort: [AATreeNode] * AATreeOrder * AATreeType -> AATreeNode
    insort(n, order, x) == 
        if n = nil then
            mk_AATreeNode(x, 1, nil, nil)
        else
            let mk_AATreeNode(y, k, t, u) = n,
                leq: bool = order(x, y),
                r: AATreeNode =  
                    mk_AATreeNode(y, k, 
                            if     leq then insort(t, order, x) else t,
                            if not leq then insort(u, order, x) else u)
            in 
                split(skew(r))
    pre x <> nil and 
    measure 
        is not yet specified
    --    n.level
    -- not quite as might go up and down; perhaps depth(n) - n.level? 
    ;

    --@IsaLemma(dataset_skew_split, 
    --      forall n: [AATreeNode] & 
    --          dataset(skew(n)) = dataset(n) and dataset(n) = dataset(split(n)))

    --@IsaLemma(wf_skew_split, forall n: [AATreeNode] & wf(n) => skew(n) = n and split(n) = n)

    --@IsaLemma(wf_insort, 
    --      forall n: [AATreeNode], o: AATreeOrder, x: AATreeType &
    --          wf(n) => wf(insort(n, order, x)) )

end AATree